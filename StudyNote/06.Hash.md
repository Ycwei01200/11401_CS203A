# Hash (雜湊)
***
### 關於 Hash 
    ## Hash是甚麼(What)?
        * 是一種資料結構，儲存key-Value配對的集合。
        * Key-Value(鍵值對):可以想像成字典中的字母(key)，在對應的字母中可以找到你想找的單字。
    ## Hash甚麼情況會用到(When)?
        * 像是加密(`encryption`)時，可以透過hash去把你的`key`，透過`hash function`的設計去加密成`index`。
    ## Hash要怎麼運用(How)?
        * Hash function的設計: 
            1. 因為良好的Hash function，會關乎到整個資料的**效率**以及**分布的均勻性**。
            2. **m 值(Hash table 的大小)**的設定:通常會設定為質數，可以讓資料均勻分配，進而減少衝突的發生。
        * Collision(衝突)的處理:
            1. **Chaining(鏈結法)**
            2. **Open Addressing**
            3. **Composite Hashing**
            4. **Hash Refinement**

    ## Hash 的優缺點(`Pros`/`Cons`)
        * `Pros`: 
            1. 省去了查找資料的時間，面對龐大的資料，能夠快速計算出索引值(index)，進而得到資料
            2. Time Complexity(`Chaining`)
            3. Time Complexity(`Open Addressing`)
        * `Cons`:
            1. 發生衝突(`Collision`)時，運作效率上會變差(**詳情請看下方敘述**)
### Time Complexity
    ## Chaining(鏈結法): ※`α` = **N/M**
        Insertion:`Best Case`: $O(1)$ `Average Case`: $O(1+α)$ `Worst Case`: $O(N)$
        Search:   `Best Case`: $O(1)$ `Average Case`: $O(1+α)$ `Worst Case`: $O(N)$
        Deletion: `Best Case`: $O(1)$ `Average Case`: $O(1+α)$ `Worst Case`: $O(N)$
    ## Open Addressing: ※`α` = **N/M**
        Insertion:`Best Case`: $O(1)$ `Worst Case`: $O(N)$
        Search:   `Best Case`: $O(1)$ `Worst Case`: $O(N)$
        Deletion: `Best Case`: $O(1)$ `Worst Case`: $O(N)$
### 運作流程(Operation):
    ## 基本操作:
        * key -> hash function(**Covert key to index**) -> index -> value
    ## Collision(衝突):
        * Normal situation: Every pair of key-value is unique , Only have one value for one key.
        * Definition: Many value mapped to the same index.
        * Solution:
            1. Chaining(鏈結法):
                * Definition:運用`Array` +  `Linked List`的設計，使每個index可以儲存多個value。
                * Pros:
                    1. 運用到Linked List的特點:插入/刪除的Time Complexity都是 $O(1)$ (已知節點位置的情況下)
                    2. dynamic size: 透過`Rehashing`的設計，調整`M`的大小，以避免Collision的發生
                * Cons:
                    1. 實作較為複雜，尤其Linked list涉及對於指標的管理
                    2. dynamic size: 透過不斷的realloc/malloc，除了會不斷地對記憶體進行操作，實際上也會比array的速度來的慢(directly access)
                    3. Collision: 當衝突產生時，如果Linked list的長度過長，會影響到插入/刪除/搜尋的效率(Worst Case:$O(N)$)
            2. Open Addressing(開放定指法):
                * Definition:針對`hash function`的設計，使得probing的運作更有分佈性，進而減少衝突的發生。
                * 種類:
                    1. linear probing:
                        * Formula: $(h(k)+i) \mod m = index$
                        * Pros:
                            1.simple
                        * Cons:
                            1.primary clustering:當發生衝突時，會**連續地**往下尋找空的儲存格(slot)，進而形成一個巨大的集合，同時影響到效率
                    2. quadratic probing:
                        * Formula: $(h(k) + C_1 \cdot i^2 + C_2 \cdot i) \mod m = index$
                        * Pros:
                            1.資料的分佈更加均勻
                        * Cons:
                            1.secondary clustering:當發生衝突時，會**非連續地**跳躍尋找空的儲存格(slot)，進而形成一個巨大的集合，同時影響到效率
                    3. double hashing:
                        * Formula: $(h_1(k) + i \cdot h_2(k)) \mod m = index$
                        * Pros:
                            1.資料的分佈更加均勻
                        * Cons:
                            1.涉及到兩個`hash function`的設計，對於運算的速度會較慢
            3. Composite Hashing:
                * Definition: 考量更多資料的屬性(attribute) 以及類別(classification)，進而設計出更有效的`hash function`。
            4. Hash Refinement
                * Definition: 字如其名，是對`hash function`進行優化，進而減少衝突的發生。
### Abstract Data Type(ADT):
    ## Vocabulary:
        * Create(D,m):create a hash table 'D' with size 'm'
        * Search(D,k):search for key 'k' in hash table 'D'
        * Insert(D,k,v):insert key 'k' with value 'v' into hash table 'D'
        * Delete(D,k):delete key 'k' from hash table 'D'    
### Comparison:
    ## Static Hashing:
        * Size : `Fixed`
        * Load Factor : `α = N/M` higher -> more collision
        * Hash Function : `Constant` 
        * Rehashing : `Rebuild the hash table`
        * Implement: `Simple`
        * Best Use Case: Fixed data set / simple.
    ## Dynamic Hashing:
        * Size : `Dynamic`
        * Load Factor : `Remain efficient`
        * Hash Function : `adaptive`
        * Rehashing : `Reallocate the memory to a new hash table`
        * Implement: `Complex`
        * Best Use Case: Dynamic data set / complex.