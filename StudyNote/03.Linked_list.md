#  Linked List (éˆçµé™£åˆ—) ç­†è¨˜
***
Creater: Yu-Cheng Wei <br>
Gmail  : <iixun01200.tw@gmail.com>
***
##  é—œæ–¼ Linked List (åŸºç¤æ¦‚å¿µ)

* ### Linked List æ˜¯ç”šéº¼ (What)?
    - æ˜¯ä¸€ç¨®èƒ½å¤ æŠŠæ¯æ¨£æ±è¥¿ï¼Œç”¨éˆçµçš„æ–¹å¼é€£æ¥èµ·ä¾†çš„è³‡æ–™çµæ§‹ã€‚
    - æ•´å€‹ Linked List ä¸€å®šæœƒæœ‰ä¸€å€‹**head**ï¼ˆé ­éƒ¨ï¼‰è·Ÿ**tail**ï¼ˆå°¾éƒ¨ï¼‰ã€‚

* ### Linked List ä½•æ™‚ç”¨ (When)?
    - ç•¶ä½ æ¯”è¼ƒé »ç¹åœ°é€²è¡Œ**æ’å…¥**æˆ–**åˆªé™¤**è³‡æ–™æ™‚ï¼Œå°±é©åˆä½¿ç”¨ã€‚

* ### Linked List ç‚ºä½•ç”¨ (Why)?
    - æ’å…¥/åˆªé™¤è³‡æ–™çš„æ™‚é–“è¤‡é›œåº¦ä½ ($O(1)$)ï¼Œå› ç‚ºä¸éœ€è¦ç§»å‹•å¤§é‡é€£çºŒçš„å…ƒç´ ã€‚

* ### Linked List åœ¨å“ªè£¡ç”¨ (Where)?
    - To-do list / Check list / è³‡æ–™çµæ§‹ (Data Structure) çš„åŸºç¤å¯¦ä½œã€‚

* ### Linked List çš„ç¨®é¡
    - **Singular Linked List** (å–®å‘éˆçµçµæ§‹)
    - **Doubly Linked List** (é›™å‘éˆçµçµæ§‹)
    - **Circular Linked List** (å¾ªç’°éˆçµçµæ§‹)

---
## è¨˜æ†¶ä¸é€£çºŒæ€§?
    - Array (contineuous access): é€£çºŒåœ°è³‡æ–™å­˜å„²ç©ºé–“ï¼Œå¯åˆ†ç‚º**static** / **dynamic** arrayã€‚
    - Linked List(sequencial access):ä¸é€£çºŒåœ°è³‡æ–™å­˜å„²ç©ºé–“ï¼Œéœ€äº‹å…ˆåˆ†é…ç©ºé–“(always dynamic)ã€‚


## ç¨®é¡è©³è§£ (Types)

* ### Singular Linked List (å–®å‘)
    - åªæœ‰å–®ä¸€æ–¹å‘ï¼Œæ¯çµ„ç¯€é»åªå­˜æ”¾ä¸€å€‹æŒ‡å‘**ä¸‹ä¸€å€‹ç¯€é»**çš„æŒ‡æ¨™ã€‚
    
    ![Singular Linked List ç¤ºæ„åœ–:Created by Gemini](https://github.com/Ycwei01200/11401_CS203A/blob/main/Picture/Singular_Linked_list.png?raw=true)
    -Singular Linked List ç¤ºæ„åœ–:Created by Gemini

* ### Doubly Linked List (é›™å‘)
    - å…·æœ‰å…©å€‹æ–¹å‘ï¼Œæ¯å€‹ç¯€é»å­˜æ”¾ä¸€å€‹æŒ‡å‘**å‰æ–¹**ï¼ˆPrevï¼‰èˆ‡ä¸€å€‹æŒ‡å‘**å¾Œæ–¹**ï¼ˆNextï¼‰çš„æŒ‡æ¨™ã€‚
    ![Doubly Linked List Node](https://www.alphacodingskills.com/imgfiles/doubly-linked-list-node.PNG)
     [Resource](https://www.alphacodingskills.com/ds/circular-doubly-linked-list.php)


* ### Circular Linked List (å¾ªç’°)
    - ç´°åˆ†ç‚º Singular / Doubly Circular Linked Listã€‚
    - **Singular Circular Linked List:** åªæœ‰å–®ä¸€æ–¹å‘ï¼Œä½† **Tail** å¾Œæ–¹æ¥è‘— **Head**ã€‚
    - **Doubly Circular Linked List:** å…·æœ‰å…©å€‹æ–¹å‘ï¼Œä¸” **Tail** å¾Œæ–¹æ¥è‘— **Head**ã€‚
    ![Circular Linked List](https://i0.wp.com/learnersbucket.com/wp-content/uploads/2019/09/Circular-linked-list-1.png?w=768&ssl=1)
    [Resource](https://www.alphacodingskills.com/imgfiles/doubly-linked-list-node.PNG)


---
## Linked List ADT(Abstract data Structure)
    - Insert before
    - Insert after
    - Delete by value
    - Delete by position
    - Delete before
    - Delete after

## ğŸ› ï¸ Linked List çš„å¯¦ä½œèˆ‡æ“ä½œ (C++)

* ### Linked List åœ¨ C++ é€šå¸¸ä»¥ `struct` ä¾†å¯¦ä½œ (Node å®šç¾©)

    ```c++
    #include <iostream>

    struct Node {
    	int value; Â // æ¯ä¸€å€‹ç¯€é»çš„è³‡æ–™
    	Node* next; // æŒ‡å‘ä¸‹ä¸€å€‹ç¯€é»
    }; // çµæ§‹å®šç¾©çµå°¾éœ€è¦åˆ†è™Ÿ

    int main() {
    	// å®£å‘Šæœ‰ä¸€å€‹æ–°çš„ç¯€é»
    	Node* head = new Node(); 
    	head->value = 1; // å­˜æ”¾ç¯€é»çš„è³‡æ–™ (æ³¨æ„: è®Šæ•¸åå·²ä¿®æ­£ç‚º value)

    	// å¯¦ä½œçµæŸå¾Œéœ€è¦é‡‹æ”¾è¨˜æ†¶é«”
    	delete head;
    	return 0;
    }
    ```

* ### æ’å…¥ (Insertion)

    * #### æ’å…¥åœ¨é–‹é ­
        ```c++
        void insertion_in_head(node*& head,int val){
        	node* new_headÂ  = new node(); //å»ºé€ ä¸€å€‹æ–°çš„ç¯€é»
        	new_head->value = val; //ä¸¦é€²è¡Œå­˜å€¼
        	new_head->nextÂ  = head; //é€£æ¥åŸæœ¬çš„ç¯€é»(head)
        	headÂ  Â  Â  Â  Â  Â  = new_head; //æŠŠæ–°çš„ç¯€é»é€£æ¥
        }
        ```
    
    * #### æ’å…¥åœ¨ä¸­é–“
        ```c++
        void insertion_in_middle(node*& head, int goal, int val){
        node* prev = head;
        Â 
        // æ‰¾åˆ° goal å‰ä¸€å€‹ç¯€é»
        while(prev->next->value != goal){
        	prev = prev->next;
        }

        node* insert_node = new node();
        insert_node->value = val;
        insert_node->next = prev->next;
        prev->next = insert_node;
        }

        ```
    
    * #### æ’å…¥åœ¨å¾Œé¢
        ```c++
        void insertion_in_tail(node*& head,int val){
        	node* current = head;
        	node* new_tail= new node();Â 
        	new_tail->value = val;new_tail->next = NULL;
        	while(current->next != NULL){
        		current = current -> next;
        	}
        	current->next = new_tail;
        	Â 
        	Â 
        }
        ```
*   ### åˆªé™¤ (Deletion)
    * ä»¥ä¸‹ç¨‹å¼ç¢¼æœƒæ˜¯é–¹å‰²ç‰ˆï¼Œå› ç‚ºæ˜¯é‡å°ä¸åŒæƒ…æ³é è¨­å‡ºä¾†çš„ç¨‹å¼ç¢¼ï¼Œæœƒåˆ—å‡ºå®Œæ•´ç‰ˆ
    * #### åˆªé™¤åœ¨é–‹é ­(`head`)
        ```c++
        void delete_in_head(node*& head){
        if(head == NULL) return;
        node* temp = head;//æš«å­˜èˆŠçš„æŒ‡æ¨™
        head = head->next;//ç¢ºä¿éˆçµæˆåŠŸ
        delete temp;//åˆªé™¤æŒ‡æ¨™
        }
        ```
    * #### åˆªé™¤åœ¨ä¸­é–“
        ```c++
        void delete_in_middle(node*& head, int val){
        if(head == NULL) return;
        node* current = head;
        while(current->next != NULL && current->next->value != val){//Traverse
            current = current -> next;
        }
        node* temp = current->next;//æš«å­˜èˆŠçš„æŒ‡æ¨™
        current->next = current->next->next;
        delete temp;//åˆªé™¤æŒ‡æ¨™
        }
        ```
    * #### åˆªé™¤åœ¨å°¾éƒ¨(`tail`)
        ```c++
        void delete_in_tail(node*& head){
        if(head == NULL) return;//edge cases

        if(head->next == NULL){ //åªæœ‰ä¸€å€‹ç¯€é»çš„æƒ…æ³
            delete head;
            head = NULL;
            return;
        }
        node* current = head;

        while(current->next->next != NULL){//Traverse
            current = current->next;
        }
        node* temp = current->next; // é–å®šæœ€å¾Œä¸€å€‹ç¯€é»
        current->next = NULL;       // æ–·é–‹é€£çµ
        delete temp;
        }
        ```
*   ### Swap by node operation(Poniter manipulation)
        ```c++
        void swap_by_node(node* head,int form_val,int to_val){
        if(head == NULL) return;
        node* prev_form = head;
        node* current1  = head;
        node* prev_to   = head;
        node* current2  = head;
        while(prev_form->next != NULL && prev_form->next->value != form_val){
            prev_form = prev_form->next;
        }
        current1  = prev_form->next;
        while(prev_to->next != NULL && prev_to->next->value != to_val){
            prev_to = prev_to->next;
        }
        current2  = prev_to->next;
        
        prev_form->next = prev_form->next->next;
        current1->next  = NULL;

        prev_to->next   = prev_to->next->next;
        current2->next  = NULL;

        
        current1->next = prev_to->next;
        prev_to->next  = current1;

        current2->next = prev_form->next;
        prev_form->next= current2;
        }
        ```
    ### Selection Sort(Linked List)
        - by pointer

        ```c++
        void Selection_sort_by_pointer(node*& head){
        // 1. åŸºæœ¬æª¢æŸ¥ï¼šå¦‚æœæ˜¯ç©ºä¸²åˆ—æˆ–åªæœ‰ä¸€å€‹ç¯€é»ï¼Œä¸ç”¨æ’
            if(head == NULL || head->next == NULL) return;

            // i æ˜¯ã€Œç›®å‰è¦è™•ç†çš„ä½ç½®ã€
            for(node* i = head; i->next != NULL; i = i->next){
            
            // --- æ­¥é©Ÿ A: æ‰¾å‡ºæœ€å°å€¼ ---
            node* min_node = i;       // å…ˆå‡è¨­ i è‡ªå·±æ˜¯æœ€å°çš„
            node* prev_min = NULL;    // ç´€éŒ„ min_node çš„å‰ä¸€å€‹ç¯€é» (ç‚ºäº†æ‹”å‡ºä¾†ç”¨)
            
            node* prev_j = i;         // é€™æ˜¯ j çš„å‰ä¸€å€‹ç¯€é»
            for(node* j = i->next; j != NULL; j = j->next){
                if(j->value < min_node->value){
                    min_node = j;
                    prev_min = prev_j; // è¨˜ä½æœ€å°å€¼çš„å‰ä¸€å€‹æ˜¯èª°
                }
                prev_j = j; // å¾€ä¸‹èµ°
            }

            // --- æ­¥é©Ÿ B: å¦‚æœçœŸçš„æ‰¾åˆ°æ¯” i æ›´å°çš„ç¯€é»ï¼Œå°±é€²è¡Œæ¬ç§» ---
            if(min_node != i){
                
                // 1. ã€æ‹”å‡ºä¾†ã€‘æŠŠ min_node å¾åŸæœ¬ä½ç½®ç§»é™¤
                // prev_min->next æ¥åˆ° min_node->nextï¼Œé€™æ¨£ min_node å°±æ–·é–‹äº†
                prev_min->next = min_node->next;

                // 2. ã€æ’é€²å»ã€‘æŠŠ min_node æ’åˆ° i çš„å‰é¢
                min_node->next = i;

                // 3. ã€æ¥èµ·ä¾†ã€‘è™•ç† i çš„å‰ä¸€å€‹ç¯€é»æŒ‡å‘ min_node
                if(i == head){
                    head = min_node; // å¦‚æœ i æ˜¯é ­ï¼Œé ­å°±è¦æ›äººåš
                } else {
                    // å¦‚æœ i ä¸æ˜¯é ­ï¼Œæˆ‘å€‘è¦æ‰¾åˆ° i çš„å‰ä¸€å€‹ç¯€é» (prev_i)
                    node* prev_i = head;
                    while(prev_i->next != i){
                        prev_i = prev_i->next;
                    }
                    prev_i->next = min_node; // è®“å‰ä¸€å€‹ç¯€é»æŒ‡å‘æ–°çš„ min_node
                }

                // 4. ã€æ›´æ–° iã€‘
                // å› ç‚ºæˆ‘å€‘æŠŠ min_node æ’åˆ°äº† i çš„ä½ç½®ï¼Œ
                // ç¾åœ¨ i æŒ‡æ¨™æ‡‰è©²è¦æŒ‡è‘—é€™å€‹æ–°ä½ç½® (min_node)ï¼Œ
                // é€™æ¨£è¿´åœˆçš„ i = i->next æ‰æœƒæ­£ç¢ºèµ°åˆ°ä¸‹ä¸€å€‹ä½ç½® (åŸæœ¬çš„ i)ã€‚
                i = min_node;
                    }
                }
            }   
        ```
        - by value

        ```c++
            void Selection_sort_by_value(node* head){
                if(head == NULL || head->next == NULL) return;
                for(node* i = head; i != NULL ; i = i->next){
                    node* min_node = i;
                    for(node* j = i->next; j != NULL; j = j->next){
                        if(j->value < min_node->value){
                            min_node = j;
                        }
                    }
                    if(min_node != i){
                        int temp = i->value;
                        i->value = min_node->value;
                        min_node->value = temp;
                    }
                }
            }
        ```
    ### Time complexity:
        - Array versus Linked List
    ![https://github.com/Ycwei01200/11401_CS203A/blob/main/Picture/time_complexity_Comparion.jpg?raw=true](https://github.com/Ycwei01200/11401_CS203A/blob/main/Picture/time_complexity_Comparion.jpg?raw=true)

    * #### å®Œæ•´ç‰ˆ
        * ç”±æ–¼æ”¾ä¸Šä¾†ç‰ˆé¢éæ–¼å‡Œäº‚ï¼Œè«‹ç§»é§•å»![template.cpp]ï¼Œè¬è¬!