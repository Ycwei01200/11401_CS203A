#  Array (陣列) 
***
##  陣列基礎 (What & Why)

* ### 陣列是甚麼 (What)?
    - 是一種儲存資料的方式，將資料存進去**連續的記憶體 (Contiguous Memory)** 中。
    - A collection of elements stored in contiguous memory locations, where each element can be accessed directly using an index.

* ### 甚麼時候會用到 (When)?
    - 當你需要一個空間去存放一些資料的時候。

* ### 為什麼要用陣列 (Why)?
    - 當面臨大量的資料時，就不會需要宣告很多變數，進而導致自己很混亂。
    - Array 提供一個空間去存放資料，就只要宣告一次，並且**分配大小**。

##  陣列的使用方式與類型 (How)

* ### 要怎麼用 (How)?
    - 需要先宣告一個陣列，並且告訴它你所想要存放的大小 (Dynamic/Static)。
    - 在此之前我們得先知道 Dynamic / Static array 的差別：

        ```c
        #include <stdio.h>
        #include <stdlib.h>

        int main(){
            int arr[10]; // Static array

            // Dynamic array 
            int n = 10;
            int* arr1 = (int*) malloc(sizeof(int)*n);

            free(arr1);
            return 0;
        }
        ```

    - **Dynamic (彈性/動態陣列):** - **定義:** 能夠透過修改記憶體，來去決定 Array 的大小。
        - **Such as:** `malloc` / `realloc`
        - **優點:** 適合用於 **未知大小 (Unknown)** 的資料、可以日後調整陣列大小。
        - **缺點:** 使用完需要 **釋放記憶體 (`free`)**，否則會有 **記憶體洩漏 (Memory Leaked)** 的問題。

    - **Static (靜態陣列):**
        - **定義:** 在宣告的當下就決定 Array 的大小。
        - **Such as:** `int arr[10]` / `double arr[100]`
        - **優點:** 適合用於 **已知大小 (Known)** 的資料，在編譯時就已經決定好大小、比較不會有**記憶體洩漏**的問題。
        - **缺點:** 當陣列存放資料已滿，除非覆蓋資料，否則只能宣告一個新的陣列。

##  陣列的整體優缺點

* ### 優點 (Strengths)
    - 對於已知的 **索引值 (index)**，能夠做到 **直接存取 (Directly Access)**。
    - 時間複雜度 (Time Complexity) 為 $O(1)$。

* ### 缺點 (Weaknesses)
    - 對於陣列的資料進行插入、刪除時，目標元素以外的元素都要移動。
    - 時間複雜度 (Time Complexity) 為 $O(n)$。
***
## 陣列的正式使用

- Step 1
  * 宣告
    ```c
    #include<stdio.h>
    #include<stdlib.h>
    int main(){
        int arr[10]; // static array
        int n=10;
        int* arr1 = (int*) malloc (sizeof(int)*n); //dynamic array
        // 檢查 malloc 是否成功，我考試就被這個騙
        if (arr1 == NULL) {
            printf("Memory allocation failed\n");
            return 1;
    }
        return 0;
    }
    ```
- Step 2
  * 修改大小
    ```c
    #include<stdio.h>
    #include<stdlib.h>
    int main(){
        int arr[10]; // static array
        int n=10;
        int* arr1 = (int*) malloc (sizeof(int)*n); //dynamic array
        if (arr1 == NULL) {
                printf("Memory allocation failed\n");
                return 1;
        }
        n = 5;
        int* temp =  realloc (arr1,sizeof(int)*n); //自動幫你改記憶體配置
        if (temp == NULL) {//確認你記憶體分配的行為成功與失敗
            printf("Reallocation failed\n");
            free(arr1);
            return 1;
        }
        arr1 = temp;
        free(arr1); //要釋放記憶體
        return 0;
    }
    ```
* 正式使用
  - Array ADT:
    - Create(n):Create a array with n elements
    - Access(i):return the element at the index i
    - Insert(A,i,Val):in A array,insert Val at index i
    - Delete(A,i): in A array,delete the element of the index i in A
    - Search(A, x): Find index of value x 
    - Resize(A, m): Increase or decrease the size of the array
* Sorting(排序)
  - bubble Sort:
    - 這裡就不再贅述，因為非常基本到不行的東西
    ```c
    #include<stdio.h>
    #include<stdlib.h>
    void bubble_sort(int* arr,int arr_size){
        for(int i=0;i<arr_size-1;i++){
            for(int l=1;l<=arr_size-i-1;l++){
                if(arr[l-1]>arr[l]){
                    int temp = arr[l-1];
                    arr[l-1]=arr[l];
                    arr[l] = temp;
                }
            }
        }
    }
    void print(int* arr,int arr_size){
        for(int i=0;i<arr_size;i++){
            printf(" %d ",arr[i]);
        }
    }
    int main(){
        int arr[5]={1,2,5,4,3}; // static array
        bubble_sort(arr,5);
        print(arr,5);
        return 0;
    }
    ```
  - Selection Sort:
    ```c
    #include<stdio.h>
    #include<stdlib.h>
    void selection_sort(int array[], int n) {
        for (int i=0; i<n-1; i++) {
            int min_idx = i;
            for (int j=i+1; j<n; j++) {
                if (array[j] < array[min_idx]) {
                    min_idx = j;
                }
            }
        
        int temp = array[min_idx];
        array[min_idx] = array[i];
        array[i] = temp;
    }
    }
    
    void print(int* arr,int arr_size){
        for(int i=0;i<arr_size;i++){
            printf(" %d ",arr[i]);
        }
    }
    int main(){
        int arr[5]={1,2,5,4,3}; // static array
        selection_sort(arr,5);
        print(arr,5);
        return 0;
        
    }
    ```
    - 圖解
      - 實際上的排序演算法，是透過每一輪的比大小，去移動元素，所以移動過程會長得像這樣，左邊是排序過後，右邊則是排序前
      - bubble sort就是一種非常直觀的排序法
      - **以下圖片由Chat GPT協助生成**
      -![https://github.com/Ycwei01200/11401_CS203A/blob/main/Picture/sorted_and_unsorted.png?raw=true](https://github.com/Ycwei01200/11401_CS203A/blob/main/Picture/sorted_and_unsorted.png?raw=true)
* Search(搜索)
  - Linear Search(線性搜索)
    * time complexity: **O(n)**
    * 效率最差的方式，因為得全部找過，才能確認在哪
      ```c
        #include <stdio.h>
        int find(int arr[],int arr_size,int target){
            //the worst case:you should find the last element in this array
            //the time complexity is O(n)
            for(int i=0;i<arr_size;i++){
                if(arr[i]==target)return i;
            }
            
        }
        int main()
        {
            int arr[5]={1,2,3,4,5};
            //Surposed that i would find the element "4" in this array.
            int arr_size = 5;
            int target = 4;
            printf("%d",find(arr,arr_size,target));
            
        
            return 0;
        }
   ```
- Binary Search(二分搜索法)
  * time complexity: **O(log N)**
    ```c
    #include <stdio.h>
    int binary_search(int arr[],int arr_size,int target){
        
        int Left=0,Right=arr_size-1,current;
        while(Left<=Right){
            current = Left+(Right-Left)/2;
            if(arr[current]>target){
                Right = current-1;
            }
            else if(arr[current]<target){
                Left  = current+1;
            }
            else{
                return current;
            }
        }
        return arr_size;
        
        
    }
    int main()
    {
        int arr[5]={1,2,3,4,5};
        //Surposed that i would find the element "4" in this array.
        int arr_size = 5;
        int target = 4;
        printf("%d",binary_search(arr,arr_size,target));
        
    
        return 0;
    }
    ```
   
    


    
    
